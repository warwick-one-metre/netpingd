#!/usr/bin/env python3
#
# This file is part of netpingd.
#
# netpingd is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# netpingd is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with netpingd.  If not, see <http://www.gnu.org/licenses/>.

# pylint: disable=broad-except
# pylint: disable=too-few-public-methods
# pylint: disable=no-self-use
# pylint: disable=invalid-name

"""Front end checking the internal and external network health using ping times."""

import re
import argparse
import datetime
import subprocess
import platform
import threading
import time
import Pyro4
import warwick.observatory as observatory

CONFIG = {
    'nites': observatory.daemons.nites_network_ping,
    'observatory': observatory.daemons.observatory_network_ping
}

PING_TARGETS = {
    'ngtshead': '10.2.6.250',
    'google': 'www.google.com',
    'onemetre': '10.2.6.202', # Main NUC in the w1m dome rack
    'goto': '10.2.6.9', # Left NUC in the GOTO rack
    'nites': '10.2.6.183', # Webcam in the NITES dome
    'swasp': '192.168.0.53', # Monitor machine in SWASP
    'swasp_gateway': '192.168.0.1' # Machine in the WHT
}

# This should be greater than PING_TIMEOUT * len(PING_TARGETS)
PING_LOOP = 30

PING_TIMEOUT = 2
PING_REGEX = {
    'posix' : r'rtt min/avg/max/mdev = (?P<min>\d+\.\d+)/(?P<avg>\d+\.\d+)/' \
                 + r'(?P<max>\d+\.\d+)/(?P<mdev>\d+\.\d+) ms',
    'windows' : r'    Minimum = (?P<min>\d+)ms, Maximum = (?P<max>\d+)ms, ' \
                 + r'Average = (?P<avg>\d+)ms'
}

class NetworkPingDaemon:
    """Wraps a ping request to google and ngtshead"""
    def __init__(self, name):
        self._name = name
        self._latest = None

        windows = platform.system().lower() == 'windows'
        self._regex = re.compile(PING_REGEX['windows' if windows else 'posix'])
        self._ping = ['ping', '-n', '1'] if windows else ['/usr/bin/ping', '-c1']

        # Polls the network from a background thread
        runloop = threading.Thread(target=self.__run_thread)
        runloop.daemon = True
        runloop.start()

    def __run_thread(self):
        """Run loop for monitoring the hardware daemon"""
        while True:
            start = datetime.datetime.utcnow()

            latest = {
                'date': datetime.datetime.utcnow().strftime('%Y-%m-%dT%H:%M:%SZ')
            }

            for target in PING_TARGETS:
                try:
                    latest[target] = self.ping(PING_TARGETS[target])
                except Exception as exception:
                    latest[target] = -1

                    print('{} ERROR: failed to ping {}: {}' \
                          .format(datetime.datetime.utcnow(), target, str(exception)))
                    observatory.log.error(self._name, 'Failed to ping ' + target + ' (' + \
                                                       str(exception) + ')')

            self._latest = latest
            end = datetime.datetime.utcnow()
            time.sleep(PING_LOOP - (end - start).total_seconds())

    def ping(self, address):
        """Ping an address and return the rtt time in milliseconds"""
        output = subprocess.check_output(self._ping + [address], universal_newlines=True,
                                         timeout=PING_TIMEOUT)

        # The last line of output (ignoring the final newline) contains the ping times
        times = output.split('\n')[-2]
        match = self._regex.match(times)
        if match is None:
            raise Exception('Failed to parse ping output: ' + output)

        return float(match.group('avg'))

    @Pyro4.expose
    def last_measurement(self):
        """Query the latest valid measurement.
        May return None if no data is available"""
        return self._latest

if __name__ == '__main__':
    description = 'Network monitoring server'
    parser = argparse.ArgumentParser(description=description)
    parser.add_argument('instrument', choices=CONFIG.keys(), help='Select an instrument')
    args = parser.parse_args()
    CONFIG[args.instrument].launch(NetworkPingDaemon(args.instrument + '_netpingd'))
