#!/usr/bin/env python3
#
# This file is part of netpingd.
#
# netpingd is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# netpingd is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with netpingd.  If not, see <http://www.gnu.org/licenses/>.

# pylint: disable=broad-except
# pylint: disable=too-few-public-methods
# pylint: disable=no-self-use
# pylint: disable=invalid-name

"""Front end checking pings to evaluate the Warwick one-metre telescope network availability"""

import re
import argparse
import datetime
import subprocess
import platform
import threading
import time
import Pyro4
import warwick.observatory as observatory

CONFIG = {
    'nites': observatory.daemons.nites_network_ping,
    'onemetre': observatory.daemons.onemetre_network_ping
}

PING_LOOP = 30

PING_TIMEOUT = 2
PING_REGEX = {
    'posix' : r'rtt min/avg/max/mdev = (?P<min>\d+\.\d+)/(?P<avg>\d+\.\d+)/' \
                 + r'(?P<max>\d+\.\d+)/(?P<mdev>\d+\.\d+) ms',
    'windows' : r'    Minimum = (?P<min>\d+)ms, Maximum = (?P<max>\d+)ms, ' \
                 + r'Average = (?P<avg>\d+)ms'
}

class NetworkPingDaemon:
    """Wraps a ping request to google and ngtshead"""
    def __init__(self, name):
        self._name = name
        self._latest = None

        windows = platform.system().lower() == 'windows'
        self._regex = re.compile(PING_REGEX['windows' if windows else 'posix'])
        self._ping = ['ping', '-n', '1'] if windows else ['/usr/bin/ping', '-c1']

        # Polls the network from a background thread
        runloop = threading.Thread(target=self.__run_thread)
        runloop.daemon = True
        runloop.start()

    def __run_thread(self):
        """Run loop for monitoring the hardware daemon"""
        while True:
            try:
                self._latest = {
                    'date': datetime.datetime.utcnow().strftime('%Y-%m-%dT%H:%M:%SZ'),
                    'ngtshead': self.ping('ngtshead.warwick.ac.uk'),
                    'google': self.ping('www.google.com'),
                }
            except Exception as exception:
                print('{} ERROR: failed to ping network: {}' \
                      .format(datetime.datetime.utcnow(), str(exception)))
                observatory.log.error(self._name, 'Failed to ping network (' + str(exception) + ')')

            time.sleep(PING_LOOP)

    def ping(self, address):
        """Ping an address and return the rtt time in milliseconds"""
        output = subprocess.check_output(self._ping + [address], universal_newlines=True,
                                         timeout=PING_TIMEOUT)

        # The last line of output (ignoring the final newline) contains the ping times
        times = output.split('\n')[-2]
        match = self._regex.match(times)
        if match is None:
            raise Exception('Failed to parse ping output: ' + output)

        return float(match.group('avg'))

    @Pyro4.expose
    def last_measurement(self):
        """Query the latest valid measurement.
        May return None if no data is available"""
        return self._latest

if __name__ == '__main__':
    description = 'Net Pinging Server'
    parser = argparse.ArgumentParser(description=description)
    parser.add_argument('instrument', choices=['onemetre', 'nites'], help='Select an instrument')
    args = parser.parse_args()
    CONFIG[args.instrument].launch(NetworkPingDaemon(args.instrument + '_netpingd'))

